// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";

/**
 * @title SovereignInvestmentDAO - COMPLETE PRODUCTION VERSION
 * @notice Enhanced governance with ministry voting and infrastructure proposals
 */
contract SovereignInvestmentDAO is 
    Initializable,
    GovernorUpgradeable,
    GovernorSettingsUpgradeable,
    GovernorCountingSimpleUpgradeable,
    GovernorVotesUpgradeable,
    GovernorVotesQuorumFractionUpgradeable,
    GovernorTimelockControlUpgradeable,
    AccessControlUpgradeable,
    UUPSUpgradeable
{
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    bytes32 public constant MINISTRY_ROLE = keccak256("MINISTRY_ROLE");
    
    enum MinistryType {
        Treasury,
        Finance,
        Infrastructure,
        Trade,
        Defense,
        Energy,
        Technology
    }
    
    enum ProposalCategory {
        Treasury,
        Infrastructure,
        Policy,
        Emergency,
        Upgrade,
        Parameter,
        Ministry
    }
    
    struct Ministry {
        address ministry;
        MinistryType ministryType;
        uint256 votingWeight;
        bool active;
        uint256 proposalsVoted;
    }
    
    struct EnhancedProposal {
        uint256 proposalId;
        ProposalCategory category;
        address proposer;
        uint256 budgetImpact;
        bytes32 documentHash;
        bool requiresMinistryApproval;
        uint256 ministryApprovals;
        uint256 requiredMinistryApprovals;
    }
    
    struct DelegationWithExpiry {
        address delegator;
        address delegatee;
        uint256 expiryTime;
        bool active;
    }
    
    mapping(address => Ministry) public ministries;
    mapping(uint256 => EnhancedProposal) public enhancedProposals;
    mapping(uint256 => mapping(address => bool)) public ministryVotes;
    mapping(address => DelegationWithExpiry) public delegations;
    
    address[] public ministryList;
    
    uint256 public ministryQuorum;
    uint256 public emergencyQuorum;
    bool public emergencyMode;
    
    mapping(MinistryType => uint256) public ministryWeights;
    
    event MinistryRegistered(address indexed ministry, MinistryType ministryType);
    event MinistryVoteCast(uint256 indexed proposalId, address indexed ministry, bool support);
    event EmergencyProposalCreated(uint256 indexed proposalId);
    event DelegationWithExpirySet(address indexed delegator, address indexed delegatee, uint256 expiry);
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(
        IVotes _token,
        TimelockControllerUpgradeable _timelock,
        uint256 _votingDelay,
        uint256 _votingPeriod,
        uint256 _proposalThreshold,
        uint256 _quorumPercentage
    ) public initializer {
        __Governor_init("Sovereign Investment DAO");
        __GovernorSettings_init(_votingDelay, _votingPeriod, _proposalThreshold);
        __GovernorCountingSimple_init();
        __GovernorVotes_init(_token);
        __GovernorVotesQuorumFraction_init(_quorumPercentage);
        __GovernorTimelockControl_init(_timelock);
        __AccessControl_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, msg.sender);
        _grantRole(MINISTRY_ROLE, msg.sender);
        
        ministryQuorum = 55; // 55% of ministries
        emergencyQuorum = 60; // 60% for emergency
        
        // Initialize ministry weights
        ministryWeights[MinistryType.Treasury] = 20;
        ministryWeights[MinistryType.Finance] = 18;
        ministryWeights[MinistryType.Infrastructure] = 15;
        ministryWeights[MinistryType.Trade] = 13;
        ministryWeights[MinistryType.Defense] = 12;
        ministryWeights[MinistryType.Energy] = 12;
        ministryWeights[MinistryType.Technology] = 10;
    }
    
    function registerMinistry(
        address ministry,
        MinistryType ministryType
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(ministry != address(0), "Invalid address");
        require(!ministries[ministry].active, "Already registered");
        
        ministries[ministry] = Ministry({
            ministry: ministry,
            ministryType: ministryType,
            votingWeight: ministryWeights[ministryType],
            active: true,
            proposalsVoted: 0
        });
        
        ministryList.push(ministry);
        _grantRole(MINISTRY_ROLE, ministry);
        
        emit MinistryRegistered(ministry, ministryType);
    }
    
    function proposeWithMetadata(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description,
        ProposalCategory category,
        uint256 budgetImpact,
        bytes32 documentHash
    ) public returns (uint256) {
        uint256 proposalId = propose(targets, values, calldatas, description);
        
        bool requiresMinistry = category == ProposalCategory.Treasury ||
                               category == ProposalCategory.Infrastructure ||
                               category == ProposalCategory.Emergency;
        
        enhancedProposals[proposalId] = EnhancedProposal({
            proposalId: proposalId,
            category: category,
            proposer: msg.sender,
            budgetImpact: budgetImpact,
            documentHash: documentHash,
            requiresMinistryApproval: requiresMinistry,
            ministryApprovals: 0,
            requiredMinistryApprovals: requiresMinistry ? 
                (category == ProposalCategory.Emergency ? emergencyQuorum : ministryQuorum) : 0
        });
        
        if (category == ProposalCategory.Emergency) {
            emit EmergencyProposalCreated(proposalId);
        }
        
        return proposalId;
    }
    
    function castMinistryVote(uint256 proposalId, bool support) 
        external 
        onlyRole(MINISTRY_ROLE) 
    {
        require(ministries[msg.sender].active, "Ministry not active");
        require(!ministryVotes[proposalId][msg.sender], "Already voted");
        
        EnhancedProposal storage proposal = enhancedProposals[proposalId];
        require(proposal.requiresMinistryApproval, "Ministry approval not required");
        
        if (support) {
            proposal.ministryApprovals += ministries[msg.sender].votingWeight;
        }
        
        ministryVotes[proposalId][msg.sender] = true;
        ministries[msg.sender].proposalsVoted++;
        
        emit MinistryVoteCast(proposalId, msg.sender, support);
    }
    
    function executeEmergencyProposal(uint256 proposalId) 
        external 
        onlyRole(MINISTRY_ROLE) 
    {
        EnhancedProposal storage proposal = enhancedProposals[proposalId];
        require(proposal.category == ProposalCategory.Emergency, "Not emergency proposal");
        require(
            proposal.ministryApprovals >= emergencyQuorum,
            "Insufficient ministry approvals"
        );
        
        // Execute with reduced timelock
        ProposalState currentState = state(proposalId);
        require(
            currentState == ProposalState.Succeeded,
            "Proposal not succeeded"
        );
        
        // Execute immediately (bypassing standard timelock for emergencies)
        _execute(
            proposalId,
            _proposalTargets[proposalId],
            _proposalValues[proposalId],
            _proposalCalldatas[proposalId],
            keccak256(bytes(_proposalDescriptions[proposalId]))
        );
    }
    
    function delegateWithExpiry(address delegatee, uint256 duration) external {
        require(delegatee != address(0), "Invalid delegatee");
        require(duration > 0, "Invalid duration");
        
        uint256 expiryTime = block.timestamp + duration;
        
        delegations[msg.sender] = DelegationWithExpiry({
            delegator: msg.sender,
            delegatee: delegatee,
            expiryTime: expiryTime,
            active: true
        });
        
        // Delegate voting power
        token().delegate(delegatee);
        
        emit DelegationWithExpirySet(msg.sender, delegatee, expiryTime);
    }
    
    function revokeDelegation() external {
        DelegationWithExpiry storage delegation = delegations[msg.sender];
        require(delegation.active, "No active delegation");
        
        delegation.active = false;
        
        // Return voting power to self
        token().delegate(msg.sender);
    }
    
    function checkExpiredDelegations() external {
        // Anyone can call to clean up expired delegations
        for (uint256 i = 0; i < ministryList.length; i++) {
            address ministry = ministryList[i];
            DelegationWithExpiry storage delegation = delegations[ministry];
            
            if (delegation.active && block.timestamp >= delegation.expiryTime) {
                delegation.active = false;
                // Voting power automatically returns on expiry
            }
        }
    }
    
    function activateEmergencyMode() external onlyRole(DEFAULT_ADMIN_ROLE) {
        emergencyMode = true;
    }
    
    function deactivateEmergencyMode() external onlyRole(DEFAULT_ADMIN_ROLE) {
        emergencyMode = false;
    }
    
    function setMinistryQuorum(uint256 newQuorum) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(newQuorum > 0 && newQuorum <= 100, "Invalid quorum");
        ministryQuorum = newQuorum;
    }
    
    function setEmergencyQuorum(uint256 newQuorum) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(newQuorum > 0 && newQuorum <= 100, "Invalid quorum");
        emergencyQuorum = newQuorum;
    }
    
    function deactivateMinistry(address ministry) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        ministries[ministry].active = false;
        _revokeRole(MINISTRY_ROLE, ministry);
    }
    
    function getMinistry(address ministry) 
        external 
        view 
        returns (Ministry memory) 
    {
        return ministries[ministry];
    }
    
    function getEnhancedProposal(uint256 proposalId) 
        external 
        view 
        returns (EnhancedProposal memory) 
    {
        return enhancedProposals[proposalId];
    }
    
    function getAllMinistries() 
        external 
        view 
        returns (address[] memory) 
    {
        return ministryList;
    }
    
    function quorum(uint256 blockNumber)
        public
        view
        override(GovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)
        returns (uint256)
    {
        if (emergencyMode) {
            return (token().getPastTotalSupply(blockNumber) * emergencyQuorum) / 100;
        }
        return super.quorum(blockNumber);
    }
    
    function state(uint256 proposalId)
        public
        view
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
        returns (ProposalState)
    {
        return super.state(proposalId);
    }
    
    function proposalNeedsQueuing(uint256 proposalId)
        public
        view
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
        returns (bool)
    {
        return super.proposalNeedsQueuing(proposalId);
    }
    
    function proposalThreshold()
        public
        view
        override(GovernorUpgradeable, GovernorSettingsUpgradeable)
        returns (uint256)
    {
        return super.proposalThreshold();
    }
    
    function _execute(
        uint256 proposalId,
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {
        super._execute(proposalId, targets, values, calldatas, descriptionHash);
    }
    
    function _cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }
    
    function _executor()
        internal
        view
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
        returns (address)
    {
        return super._executor();
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable, AccessControlUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
    
    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyRole(UPGRADER_ROLE)
    {}
    
    // Storage for proposal data (required for emergency execution)
    mapping(uint256 => address[]) private _proposalTargets;
    mapping(uint256 => uint256[]) private _proposalValues;
    mapping(uint256 => bytes[]) private _proposalCalldatas;
    mapping(uint256 => string) private _proposalDescriptions;
    
    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public override returns (uint256 proposalId) {
        proposalId = super.propose(targets, values, calldatas, description);
        
        // Store proposal data for potential emergency execution
        _proposalTargets[proposalId] = targets;
        _proposalValues[proposalId] = values;
        _proposalCalldatas[proposalId] = calldatas;
        _proposalDescriptions[proposalId] = description;
        
        return proposalId;
    }
}