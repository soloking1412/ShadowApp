// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

/**
 * @title DebtSecuritiesIssuance - COMPLETE PRODUCTION VERSION
 * @notice Complete bond issuance platform with coupon payments and secondary market
 */
contract DebtSecuritiesIssuance is 
    Initializable,
    ERC1155Upgradeable,
    AccessControlUpgradeable,
    PausableUpgradeable,
    ReentrancyGuard,
    UUPSUpgradeable
{
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant ISSUER_ROLE = keccak256("ISSUER_ROLE");
    bytes32 public constant RATING_AGENCY_ROLE = keccak256("RATING_AGENCY_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    
    enum SecurityType {
        SovereignBond,
        TreasuryBond,
        CorporateBond,
        AssetBackedSecurity,
        TradeFinanceNote,
        MunicipalBond,
        StructuredProduct
    }
    
    enum SecurityStatus {
        Proposed,
        Active,
        Matured,
        Defaulted,
        Called
    }
    
    struct DebtSecurity {
        uint256 securityId;
        SecurityType securityType;
        address issuer;
        string name;
        string isin;
        uint256 faceValue;
        uint256 totalSupply;
        uint256 outstandingAmount;
        uint256 couponRate;
        uint256 maturityDate;
        uint256 issuanceDate;
        uint256 lastCouponDate;
        uint256 couponFrequency;
        SecurityStatus status;
        bool callable;
        uint256 callDate;
        uint256 callPrice;
        bytes32 prospectusHash;
    }
    
    struct CreditRating {
        string agency;
        string rating;
        uint256 ratingDate;
        address rater;
    }
    
    struct CouponPayment {
        uint256 paymentId;
        uint256 securityId;
        uint256 amount;
        uint256 paymentDate;
        uint256 totalHolders;
        bool completed;
    }
    
    struct Trade {
        uint256 tradeId;
        uint256 securityId;
        address seller;
        address buyer;
        uint256 amount;
        uint256 price;
        uint256 tradeDate;
        uint256 settlementDate;
        bool settled;
    }

    struct IssuanceParams {
        SecurityType securityType;
        string name;
        string isin;
        uint256 faceValue;
        uint256 totalSupply;
        uint256 couponRate;
        uint256 maturityDate;
        uint256 couponFrequency;
        bool callable;
        uint256 callDate;
        uint256 callPrice;
        bytes32 prospectusHash;
    }

    mapping(uint256 => DebtSecurity) public securities;
    mapping(uint256 => CreditRating[]) public ratings;
    mapping(uint256 => CouponPayment[]) public couponPayments;
    mapping(uint256 => mapping(address => uint256)) public holderBalances;
    mapping(uint256 => address[]) public securityHolders;
    mapping(uint256 => Trade) public trades;
    
    uint256 public securityCounter;
    uint256 public couponPaymentCounter;
    uint256 public tradeCounter;
    
    uint256 public constant BASIS_POINTS = 10000;
    uint256 public constant SETTLEMENT_PERIOD = 2 days; // T+2
    
    event SecurityIssued(
        uint256 indexed securityId,
        address indexed issuer,
        SecurityType securityType,
        uint256 totalSupply
    );
    event CouponPaid(uint256 indexed securityId, uint256 indexed paymentId, uint256 amount);
    event SecurityMatured(uint256 indexed securityId);
    event SecurityCalled(uint256 indexed securityId);
    event RatingUpdated(uint256 indexed securityId, string agency, string rating);
    event TradeExecuted(
        uint256 indexed tradeId,
        uint256 indexed securityId,
        address seller,
        address buyer,
        uint256 amount
    );
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(address admin, string memory uri) public initializer {
        __ERC1155_init(uri);
        __AccessControl_init();
        __Pausable_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(ADMIN_ROLE, admin);
        _grantRole(ISSUER_ROLE, admin);
        _grantRole(RATING_AGENCY_ROLE, admin);
        _grantRole(UPGRADER_ROLE, admin);
    }
    
    function issueSecurity(IssuanceParams memory params)
        external
        onlyRole(ISSUER_ROLE)
        whenNotPaused
        returns (uint256)
    {
        require(params.faceValue > 0 && params.totalSupply > 0, "Invalid parameters");
        require(params.maturityDate > block.timestamp, "Invalid maturity");
        require(params.couponRate <= 5000, "Coupon rate too high"); // Max 50%

        if (params.callable) {
            require(
                params.callDate > block.timestamp && params.callDate < params.maturityDate,
                "Invalid call date"
            );
        }

        uint256 securityId = ++securityCounter;

        securities[securityId] = DebtSecurity({
            securityId: securityId,
            securityType: params.securityType,
            issuer: msg.sender,
            name: params.name,
            isin: params.isin,
            faceValue: params.faceValue,
            totalSupply: params.totalSupply,
            outstandingAmount: params.totalSupply,
            couponRate: params.couponRate,
            maturityDate: params.maturityDate,
            issuanceDate: block.timestamp,
            lastCouponDate: block.timestamp,
            couponFrequency: params.couponFrequency,
            status: SecurityStatus.Active,
            callable: params.callable,
            callDate: params.callDate,
            callPrice: params.callPrice,
            prospectusHash: params.prospectusHash
        });

        // Mint to issuer
        _mint(msg.sender, securityId, params.totalSupply, "");
        holderBalances[securityId][msg.sender] = params.totalSupply;
        securityHolders[securityId].push(msg.sender);

        emit SecurityIssued(securityId, msg.sender, params.securityType, params.totalSupply);

        return securityId;
    }
    
    function payCoupon(uint256 securityId) 
        external 
        payable 
        nonReentrant 
    {
        DebtSecurity storage security = securities[securityId];
        require(msg.sender == security.issuer, "Not issuer");
        require(security.status == SecurityStatus.Active, "Not active");
        require(
            block.timestamp >= security.lastCouponDate + security.couponFrequency,
            "Too early"
        );
        
        // Calculate coupon amount
        uint256 couponAmount = (security.outstandingAmount * security.faceValue * security.couponRate) / 
                               (BASIS_POINTS * 100);
        
        require(msg.value >= couponAmount, "Insufficient payment");
        
        // Distribute to holders
        address[] storage holders = securityHolders[securityId];
        uint256 totalDistributed = 0;
        
        for (uint256 i = 0; i < holders.length; i++) {
            address holder = holders[i];
            uint256 balance = holderBalances[securityId][holder];
            
            if (balance > 0) {
                uint256 holderCoupon = (couponAmount * balance) / security.outstandingAmount;
                
                (bool success, ) = holder.call{value: holderCoupon}("");
                require(success, "Transfer failed");
                
                totalDistributed += holderCoupon;
            }
        }
        
        // Record payment
        uint256 paymentId = couponPaymentCounter++;
        
        couponPayments[securityId].push(CouponPayment({
            paymentId: paymentId,
            securityId: securityId,
            amount: totalDistributed,
            paymentDate: block.timestamp,
            totalHolders: holders.length,
            completed: true
        }));
        
        security.lastCouponDate = block.timestamp;
        
        // Refund excess
        if (msg.value > totalDistributed) {
            (bool success, ) = msg.sender.call{value: msg.value - totalDistributed}("");
            require(success, "Refund failed");
        }
        
        emit CouponPaid(securityId, paymentId, totalDistributed);
    }
    
    function redeemAtMaturity(uint256 securityId) 
        external 
        payable 
        nonReentrant 
    {
        DebtSecurity storage security = securities[securityId];
        require(msg.sender == security.issuer, "Not issuer");
        require(security.status == SecurityStatus.Active, "Not active");
        require(block.timestamp >= security.maturityDate, "Not matured");
        
        // Calculate final payment (principal + final coupon)
        uint256 principalAmount = security.outstandingAmount * security.faceValue;
        uint256 finalCoupon = (principalAmount * security.couponRate) / BASIS_POINTS;
        uint256 totalPayment = principalAmount + finalCoupon;
        
        require(msg.value >= totalPayment, "Insufficient payment");
        
        // Distribute to holders
        address[] storage holders = securityHolders[securityId];
        
        for (uint256 i = 0; i < holders.length; i++) {
            address holder = holders[i];
            uint256 balance = holderBalances[securityId][holder];
            
            if (balance > 0) {
                uint256 holderPayment = (totalPayment * balance) / security.outstandingAmount;
                
                (bool success, ) = holder.call{value: holderPayment}("");
                require(success, "Transfer failed");
                
                // Burn tokens
                _burn(holder, securityId, balance);
                holderBalances[securityId][holder] = 0;
            }
        }
        
        security.status = SecurityStatus.Matured;
        security.outstandingAmount = 0;
        
        emit SecurityMatured(securityId);
    }
    
    function callSecurity(uint256 securityId) 
        external 
        payable 
        nonReentrant 
    {
        DebtSecurity storage security = securities[securityId];
        require(msg.sender == security.issuer, "Not issuer");
        require(security.callable, "Not callable");
        require(security.status == SecurityStatus.Active, "Not active");
        require(block.timestamp >= security.callDate, "Too early");
        
        uint256 totalPayment = security.outstandingAmount * security.callPrice;
        require(msg.value >= totalPayment, "Insufficient payment");
        
        // Distribute to holders
        address[] storage holders = securityHolders[securityId];
        
        for (uint256 i = 0; i < holders.length; i++) {
            address holder = holders[i];
            uint256 balance = holderBalances[securityId][holder];
            
            if (balance > 0) {
                uint256 holderPayment = (totalPayment * balance) / security.outstandingAmount;
                
                (bool success, ) = holder.call{value: holderPayment}("");
                require(success, "Transfer failed");
                
                _burn(holder, securityId, balance);
                holderBalances[securityId][holder] = 0;
            }
        }
        
        security.status = SecurityStatus.Called;
        security.outstandingAmount = 0;
        
        emit SecurityCalled(securityId);
    }
    
    function createTrade(
        uint256 securityId,
        address buyer,
        uint256 amount,
        uint256 price
    ) external nonReentrant whenNotPaused returns (uint256) {
        DebtSecurity storage security = securities[securityId];
        require(security.status == SecurityStatus.Active, "Not active");
        require(holderBalances[securityId][msg.sender] >= amount, "Insufficient balance");
        require(buyer != address(0) && buyer != msg.sender, "Invalid buyer");
        
        uint256 tradeId = ++tradeCounter;
        
        trades[tradeId] = Trade({
            tradeId: tradeId,
            securityId: securityId,
            seller: msg.sender,
            buyer: buyer,
            amount: amount,
            price: price,
            tradeDate: block.timestamp,
            settlementDate: block.timestamp + SETTLEMENT_PERIOD,
            settled: false
        });
        
        emit TradeExecuted(tradeId, securityId, msg.sender, buyer, amount);
        
        return tradeId;
    }
    
    function settleTrade(uint256 tradeId) 
        external 
        payable 
        nonReentrant 
    {
        Trade storage trade = trades[tradeId];
        require(!trade.settled, "Already settled");
        require(block.timestamp >= trade.settlementDate, "Too early");
        require(msg.sender == trade.buyer, "Not buyer");
        require(msg.value >= trade.price, "Insufficient payment");
        
        // Transfer securities
        _safeTransferFrom(trade.seller, trade.buyer, trade.securityId, trade.amount, "");
        
        // Update balances
        holderBalances[trade.securityId][trade.seller] -= trade.amount;
        holderBalances[trade.securityId][trade.buyer] += trade.amount;
        
        // Add buyer to holders if new
        if (holderBalances[trade.securityId][trade.buyer] == trade.amount) {
            securityHolders[trade.securityId].push(trade.buyer);
        }
        
        // Transfer payment to seller
        (bool success, ) = trade.seller.call{value: trade.price}("");
        require(success, "Payment failed");
        
        trade.settled = true;
        
        // Refund excess
        if (msg.value > trade.price) {
            (bool refundSuccess, ) = msg.sender.call{value: msg.value - trade.price}("");
            require(refundSuccess, "Refund failed");
        }
    }
    
    function updateRating(
        uint256 securityId,
        string memory agency,
        string memory rating
    ) external onlyRole(RATING_AGENCY_ROLE) {
        ratings[securityId].push(CreditRating({
            agency: agency,
            rating: rating,
            ratingDate: block.timestamp,
            rater: msg.sender
        }));
        
        emit RatingUpdated(securityId, agency, rating);
    }
    
    function markAsDefaulted(uint256 securityId) 
        external 
        onlyRole(ADMIN_ROLE) 
    {
        securities[securityId].status = SecurityStatus.Defaulted;
    }
    
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }
    
    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }
    
    function getSecurity(uint256 securityId) 
        external 
        view 
        returns (DebtSecurity memory) 
    {
        return securities[securityId];
    }
    
    function getRatings(uint256 securityId) 
        external 
        view 
        returns (CreditRating[] memory) 
    {
        return ratings[securityId];
    }
    
    function getCouponPayments(uint256 securityId) 
        external 
        view 
        returns (CouponPayment[] memory) 
    {
        return couponPayments[securityId];
    }
    
    function getHolders(uint256 securityId) 
        external 
        view 
        returns (address[] memory) 
    {
        return securityHolders[securityId];
    }
    
    function _update(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts
    ) internal override whenNotPaused {
        super._update(from, to, ids, amounts);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC1155Upgradeable, AccessControlUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
    
    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyRole(UPGRADER_ROLE)
    {}
    
    receive() external payable {}
}